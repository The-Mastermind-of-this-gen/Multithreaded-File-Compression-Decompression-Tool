#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <bitset>
#include <time.h>
#include <cstring>


// Note: The openfiledialog function was generated by AI. We were unaware of such a function initially.However, all other parts of the code where this function is used were written by us and are not AI generated.
// Note: The progressUpdate function and its usage in the code were heavily assisted by AI.Its sole purpose is to provide a visual indicator of progress during compression and decompression. We implemented it using AI and chose not to put any effort in it because we just wanted something to tell us whether our code is working or just stuck
// Note: we learned about bitwise operators from the ECPC Discord channel where we were solving problems related to operations on binary numbers

using namespace std;

#include "Heap.h" // I made this class
#include "HuffmanTree.h" // I also made this class
#include "HashMap.h"//guess what 
#include "compressor.h" //;>


void UpdateProgress(long bytesProcessed, long totalBytes, clock_t startTime) // this entire function is AI generated as mentioned above
{
    double percentage = (double)bytesProcessed / totalBytes * 100.0;
    clock_t currentTime = clock();
    double elapsedSeconds = (double)(currentTime - startTime) / CLOCKS_PER_SEC;

    double estimatedTotalSeconds = 0;
    double remainingSeconds = 0;

    estimatedTotalSeconds = elapsedSeconds * (100.0 / percentage);
    remainingSeconds = estimatedTotalSeconds - elapsedSeconds;

    int remainingMinutes = (int)(remainingSeconds / 60);
    int remainingSecondsDisplay = (int)(remainingSeconds) % 60;

    printf("\rProgress: %.1f%% | ETA: %dm %ds | Speed: %.1f KB/s", percentage, remainingMinutes, remainingSecondsDisplay, (bytesProcessed / 1024.0) / (elapsedSeconds > 0 ? elapsedSeconds : 1));
    
    fflush(stdout);
}

int Compress(long BlockSize = 4096000, FILE** file = NULL, char* name = nullptr) {
    
    Huffman* a = new Huffman(*file);
    TreeNode<unsigned char>* HuffmanTreeRoot = a->ConstructHuffmanTree();


    string CodesArray[256];
    a->GenerateCodes(HuffmanTreeRoot, "", CodesArray);
    delete a;

    fseek(*file, 0, SEEK_END);
    long totalFileSize = ftell(*file);
    rewind(*file);

    printf("File size: %.2f KB\n", totalFileSize / 1024.0);
    printf("Starting compression...\n");
    
    // build output filename safely (do not mutate incoming name buffer)
    string outName = std::string(name) + ".MohamedHazem";
    FILE* CompressedFile = fopen(outName.c_str(), "wb");

    if (!CompressedFile)
        return CouldNotCreateTheCompressionFile;

    // To know from where to where is the table
    int Table = 0;
    for (int i = 0; i < 256; i++) {
        if (CodesArray[i] != "") {
            Table++;
        }
    }
    fwrite(&Table, sizeof(int), 1, CompressedFile);

    // Write code table
    for (int i = 0; i < 256; i++) {
        if (CodesArray[i] != "") {
            unsigned char symbol = i;
            unsigned char len = CodesArray[i].length();
            fwrite(&symbol, 1, 1, CompressedFile);
            fwrite(" ", 1, 1, CompressedFile);
            fwrite(CodesArray[i].c_str(), 1, len, CompressedFile);
            fwrite("\n", 1, 1, CompressedFile);
        }
    }
    rewind(*file);
    // moving over the files writing the code
    char* block = new char[BlockSize];

    unsigned int bitStorage = 0;  // unsigned int :) we will use large datatype after having had two days wasted because of the short codesArray in the Huffman Tree :'( (crying emoji)
    int bitsCounter = 0;

    long totalbytes = 0;
    clock_t startTime = clock();
    clock_t lastUpdateTime = startTime;

    size_t bytesReadFromFile;
    while ((bytesReadFromFile = fread(block, 1, BlockSize, *file)) > 0)
    {
        for (size_t i = 0; i < bytesReadFromFile; i++)
        {
            string* HuffCodePtr = &CodesArray[(unsigned char)block[i]];
            const char* codeStr = HuffCodePtr->c_str(); // this is the string stored in the address of the current CodesArray element
            int codeLength = HuffCodePtr->length();

            // we iterate through the code and process it such that for each digit in the code, we convert it from string to int and add that to the storage of bits until we have 8 bits in storage ready to be converted into a byte and written to the compressed file
            for (int indexInHuffcode = 0; indexInHuffcode < codeLength; indexInHuffcode++) {
             
                bitStorage = (bitStorage << 1) | (codeStr[indexInHuffcode] - '0'); // we shift the bits in storage to the left by one place (creating a new place with 0) and then OR the bits in storage with the current character in the code. We do this to add the current character to the storage. we do - "0" to convert the digit from stirng to int
                bitsCounter++; // we increment this counter with each bit processed to know when we have 8 bits processed to turn them into a byte

                if (bitsCounter == 8) // Oh!!! we have full 8 bits now! We can take them, transform them to a byte and write that to the compressed file! 
                {
                    bitset<8> ourEightBitstoByte(bitStorage);
                    unsigned char byte = (unsigned char)ourEightBitstoByte.to_ulong();
                    fwrite(&byte, sizeof(unsigned char), 1, CompressedFile);

                    // we reset the storage of bits and counter of bits processed for the next 8 bits to be processed
                    bitStorage = bitStorage >> 8;  // we shift by 8 because we just processed 8 bits. We're done with them, so we make 8 new places for the next operation 
                    bitsCounter -= 8; // we decrement the 8 bits we processed into a byte to the compressed file from the counter
                }
            }
        }
        totalbytes += bytesReadFromFile;
        clock_t currentTime = clock();
        double timeElapsed = (double)(currentTime - lastUpdateTime) / CLOCKS_PER_SEC;

        if (timeElapsed >= 0.5) {
            UpdateProgress(totalbytes, totalFileSize, startTime);
            lastUpdateTime = currentTime;
        }
    }

    UpdateProgress(totalFileSize, totalFileSize, startTime);
    printf("\n");

    // we handle padding now
    unsigned char PaddSize = 0;
    if (bitsCounter > 0) // if there are less than 8 bits left, we get the size of bits left for full 8 bits, do the padding, convert them to a byte and write it to the compressed file
    {
        PaddSize = 8 - bitsCounter;
        // we shift remaining bits to the left with pad size (the new bits are zero by default)
        bitStorage = bitStorage << PaddSize;
        bitset<8> finalByte(bitStorage);
        unsigned char byte = (unsigned char)finalByte.to_ulong();
        fwrite(&byte, sizeof(unsigned char), 1, CompressedFile); // write that damn final byte to the compressed file!!
    }

    // write padding size for decompression later
    fwrite(&PaddSize, sizeof(unsigned char), 1, CompressedFile);

    delete[] block;
    fclose(*file);
    fclose(CompressedFile);
    return FileCompressedSuccessfuly;
}

int Decompress(long BlockSize = 4096000, FILE** file = NULL, char* name = nullptr)
{
    char* lastDot = strrchr(name, '.');
    if (lastDot) 
    {
        *lastDot = '\0'; // remove extension
    } else 
    {
        // no extension found â€” leave name unchanged
    }

    FILE* DeCompressedFile = fopen(name, "wb");
    if (!DeCompressedFile)
        return CouldNotCreateTheDeCompressionFile;

    string CodesArray[256] = { "" };
    int TableSize;

    // Read table size
    if (fread(&TableSize, sizeof(int), 1, *file) != 1)
    {
        fclose(DeCompressedFile);
        return FailedToReadTableSize;
    }

    // Table Read
    for (int i = 0; i < TableSize; i++)
    {
        unsigned char c = fgetc(*file);
        unsigned char ch = fgetc(*file); 
        while ((ch = fgetc(*file)) != '\n')
            CodesArray[c] += ch;
    }

    // Build decode hash table
    HashTable<unsigned char> decodeMap(TableSize); // hash table for faster access same as Dr.Nour code but with some modification to make it suit our code
    for (int i = 0; i < 256; i++)
    {
        if (CodesArray[i] != "")
            decodeMap.insert(const_cast<char*>(CodesArray[i].c_str()), (unsigned char)i); //const_cast<char*> is because the k is a char*
    }

    
    long CodeStart = ftell(*file);


    fseek(*file, 0, SEEK_END);
    long fileSize = ftell(*file);
    long totalCompressedSize = fileSize - CodeStart;

    fseek(*file, CodeStart, SEEK_SET);
    printf("Compressed size: %.2f KB\n", totalCompressedSize / 1024.0);
    printf("Starting decompression...\n");
    clock_t startTime = clock();
    clock_t lastUpdateTime = startTime;
    string currentCode = "";
    long totalProcessed = 0;

    // Process file in blocks
    while (totalProcessed < totalCompressedSize)
    {
        // we are checking if the remaining blocks are enough for a block size or not
        long remainingBytes = totalCompressedSize - totalProcessed;
        long bytesToRead = (remainingBytes < BlockSize) ? remainingBytes : BlockSize;

        // we reached the end so we need to remove padding it exist
        if (remainingBytes <= BlockSize)
        {
            bytesToRead = remainingBytes - 1; // Save last byte for padding info
        }

        if (bytesToRead <= 0) break;//no padding

        // Creating the CodeBlock
        char* buffer = new char[bytesToRead];
        size_t bytesRead = fread(buffer, sizeof(char), bytesToRead, *file);

        if (bytesRead == 0) {
            delete[] buffer;
            break; // End of file
        }

        // Convert buffer to string
        string ReadBlock(buffer, bytesRead);
        delete[] buffer;

        // Convert each byte to binary string
        string CodeBlock = "";
        for (size_t i = 0; i < ReadBlock.length(); ++i) {
            bitset<8> charBits((unsigned char)ReadBlock[i]);
            CodeBlock += charBits.to_string();
        }

        // handle padding on last block
        if (remainingBytes <= BlockSize) {
            // read padding byte
            unsigned char padding;
            if (fread(&padding, sizeof(char), 1, *file) == 1) {
                // remove padding bits from end
                if (padding > 0 && padding <= 8) {
                    if (padding == 8) {
                        CodeBlock = ""; // entire last byte is padding
                    }
                    else {
                        CodeBlock = CodeBlock.substr(0, CodeBlock.length() - padding);
                    }
                }
            }
        }

        for (char bit : CodeBlock) {
            currentCode += bit;
            unsigned char symbol;

            if (decodeMap.find(const_cast<char*>(currentCode.c_str()), symbol)) {
                fwrite(&symbol, sizeof(char), 1, DeCompressedFile);
                currentCode = ""; // resetting for next code
            }
        }

        totalProcessed += bytesRead;
        if (remainingBytes <= BlockSize) {
            totalProcessed += 1; 
        }
        clock_t currentTime = clock();
        double timeElapsed = (double)(currentTime - lastUpdateTime) / CLOCKS_PER_SEC;

        if (timeElapsed >= 0.5) { // update every 0.5 seconds
            UpdateProgress(totalProcessed, totalCompressedSize, startTime);
            lastUpdateTime = currentTime;
        }
    }
    UpdateProgress(totalCompressedSize, totalCompressedSize, startTime);
    printf("\n");
    fclose(*file);
    fclose(DeCompressedFile);
    return FileDeCompressedSuccessfuly;
}